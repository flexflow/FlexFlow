/* Copyright 2023 CMU, Facebook, LANL, MIT, NVIDIA, and Stanford (alphabetical)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef _FLEXFLOW_MODEL_H_
#define _FLEXFLOW_MODEL_H_
#include "computation_graph.h"
#include "executable_task_invocation.h"
#include "legion.h"
#include "legion_backing.h"
#include "op-attrs/ops/loss_functions.h"
#include "op-attrs/tensor_shape.h"
#include "optimizer.h"
#include "parallel_computation_graph.h"
#include "pcg/machine_specification.h"
#include "recompile.h"
#include "runtime/config.h"
#include "sim_environment.h"
#include "tensor_mapping.h"
#include "training_pcg.h"
#include <functional>
#include <unistd.h>
#include <utility>

namespace FlexFlow {

MachineView get_basic_data_parallel_machine_view(int num_parts, int dims);
MachineView get_basic_data_parallel_machine_view(FFConfig const &);
MachineView get_basic_data_parallel_machine_view(MachineSpecification const &);

class FFModel {
public:
  FFModel() = delete;
  FFModel(FFConfig const &,
          ComputationGraph const &,
          TrainingPCG const &,
          Optimizer const &,
          RuntimeBacking const &,
          EnableProfiling const &,
          SimEnvFactory const &,
          TensorMapping const &);

  TaskReturnAccessor execute(operator_guid_t, OpTaskInvocation const &) const;
  std::vector<TaskReturnAccessor>
      execute(std::vector<TaskInvocation> const &) const;
  TaskReturnAccessor execute(TaskInvocation const &) const;
  TaskReturnAccessor execute(ExecutableTaskInvocation const &) const;
  std::vector<TaskReturnAccessor>
      execute(std::vector<ExecutableTaskInvocation> const &) const;

  // ========================================
  // Internal APIs that should not be invoked from applications
  // ========================================
  void compile(LossFunction loss_type,
               std::vector<Metric> const &metrics,
               ComputationMode comp_mode = ComputationMode::TRAINING);
  void compile(Optimizer const &optimizer,
               LossFunction loss_type,
               std::vector<Metric> const &metrics,
               ComputationMode comp_mode = ComputationMode::TRAINING);

  // APIs for setting iteration configs
private:
  void create_label_tensor(LossFunction);

public:
  // user-provided
  FFConfig config;
  ComputationGraph computation_graph;
  Optimizer optimizer;
  EnableProfiling enable_profiling;

  // generated by compiler (ComputationGraph -> PCG)
  TrainingPCG training_pcg;
  TensorMapping tensor_map; // maps ComputationGraph tensor to PCG tensors
                            // to enable get_tensor, set_tensor
                            // at best an approximation at the moment

  // where we put all the legion stuff -- all the runtime state
  RuntimeBacking runtime_backing;

  // profiling operators
  SimEnvFactory sim_factory;

  FFIterationConfig iter_config;
  /* optional<ParallelTensor> parallel_label_tensor; */
  /* optional<Tensor> label_tensor; */
};

void init_operators(FFModel const &);
void forward(FFModel const &, int seq_length = -1);
void backward(FFModel const &, int seq_length = -1);
void update(FFModel const &);
void zero_gradients(FFModel const &);
void reset_metrics(FFModel const &);
TypedFuture<PerfMetrics> compute_metrics(FFModel const &);
void recompile_on_condition(FFModel const &, RecompileState &r);
template <typename T>
void set_tensor(FFModel const &, TensorDims const &, T const *);
template <typename T>
void get_tensor(FFModel const &, tensor_guid_t, T *data);

ExecutableTaskInvocation resolve(TaskInvocation const &,
                                 EnableProfiling enable_profiling,
                                 RuntimeBacking const &runtime_backing);

void top_level_task(Legion::Task const *task,
                    std::vector<Legion::PhysicalRegion> const &regions,
                    Legion::Context ctx,
                    Legion::Runtime *runtime);

void data_load_task(Legion::Task const *task,
                    std::vector<Legion::PhysicalRegion> const &regions,
                    Legion::Context ctx,
                    Legion::Runtime *runtime);

void register_custom_tasks();

} // namespace FlexFlow

#endif
