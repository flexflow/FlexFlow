// THIS FILE WAS AUTO-GENERATED BY proj. DO NOT MODIFY IT!
// If you would like to modify this datatype, instead modify
// lib/pcg/include/pcg/initializer_attrs.variant.toml
/* proj-data
{
  "generated_from": "f66f3a89ea937e96a058d83ab52e2826"
}
*/

#ifndef _FLEXFLOW_LIB_PCG_INCLUDE_PCG_INITIALIZER_ATTRS_DTG_H
#define _FLEXFLOW_LIB_PCG_INCLUDE_PCG_INITIALIZER_ATTRS_DTG_H

#include "fmt/format.h"
#include "nlohmann/json.hpp"
#include "pcg/initializers/constant_initializer_attrs.dtg.h"
#include "pcg/initializers/glorot_uniform_attrs.dtg.h"
#include "pcg/initializers/norm_initializer_attrs.dtg.h"
#include "pcg/initializers/uniform_initializer_attrs.dtg.h"
#include "pcg/initializers/zero_initializer_attrs.dtg.h"
#include <cstddef>
#include <functional>
#include <ostream>
#include <type_traits>
#include <variant>

namespace FlexFlow {
struct InitializerAttrs {
  InitializerAttrs() = delete;
  explicit InitializerAttrs(::FlexFlow::GlorotUniformAttrs const &);
  explicit InitializerAttrs(::FlexFlow::ZeroInitializerAttrs const &);
  explicit InitializerAttrs(::FlexFlow::UniformInitializerAttrs const &);
  explicit InitializerAttrs(::FlexFlow::NormInitializerAttrs const &);
  explicit InitializerAttrs(::FlexFlow::ConstantInitializerAttrs const &);
  template <typename T>
  static constexpr bool IsPartOfInitializerAttrs_v =
      std::is_same_v<T, ::FlexFlow::GlorotUniformAttrs> ||
      std::is_same_v<T, ::FlexFlow::ZeroInitializerAttrs> ||
      std::is_same_v<T, ::FlexFlow::UniformInitializerAttrs> ||
      std::is_same_v<T, ::FlexFlow::NormInitializerAttrs> ||
      std::is_same_v<T, ::FlexFlow::ConstantInitializerAttrs>;
  template <typename ReturnType, typename Visitor>
  ReturnType visit(Visitor &&v) const {
    switch (this->index()) {
      case 0: {
        ReturnType result = v(this->get<::FlexFlow::GlorotUniformAttrs>());
        return result;
      }
      case 1: {
        ReturnType result = v(this->get<::FlexFlow::ZeroInitializerAttrs>());
        return result;
      }
      case 2: {
        ReturnType result = v(this->get<::FlexFlow::UniformInitializerAttrs>());
        return result;
      }
      case 3: {
        ReturnType result = v(this->get<::FlexFlow::NormInitializerAttrs>());
        return result;
      }
      case 4: {
        ReturnType result =
            v(this->get<::FlexFlow::ConstantInitializerAttrs>());
        return result;
      }
      default: {
        throw std::runtime_error(fmt::format(
            "Unknown index {} for type InitializerAttrs", this->index()));
      }
    }
  }
  template <typename ReturnType, typename Visitor>
  ReturnType visit(Visitor &&v) {
    switch (this->index()) {
      case 0: {
        ReturnType result = v(this->get<::FlexFlow::GlorotUniformAttrs>());
        return result;
      }
      case 1: {
        ReturnType result = v(this->get<::FlexFlow::ZeroInitializerAttrs>());
        return result;
      }
      case 2: {
        ReturnType result = v(this->get<::FlexFlow::UniformInitializerAttrs>());
        return result;
      }
      case 3: {
        ReturnType result = v(this->get<::FlexFlow::NormInitializerAttrs>());
        return result;
      }
      case 4: {
        ReturnType result =
            v(this->get<::FlexFlow::ConstantInitializerAttrs>());
        return result;
      }
      default: {
        throw std::runtime_error(fmt::format(
            "Unknown index {} for type InitializerAttrs", this->index()));
      }
    }
  }
  template <typename T>
  bool has() const {
    static_assert(
        IsPartOfInitializerAttrs_v<T>,
        "InitializerAttrs::has() expected one of "
        "[::FlexFlow::GlorotUniformAttrs, ::FlexFlow::ZeroInitializerAttrs, "
        "::FlexFlow::UniformInitializerAttrs, "
        "::FlexFlow::NormInitializerAttrs, "
        "::FlexFlow::ConstantInitializerAttrs], received T");
    return std::holds_alternative<T>(this->raw_variant);
  }
  template <typename T>
  T const &get() const {
    static_assert(
        IsPartOfInitializerAttrs_v<T>,
        "InitializerAttrs::get() expected one of "
        "[::FlexFlow::GlorotUniformAttrs, ::FlexFlow::ZeroInitializerAttrs, "
        "::FlexFlow::UniformInitializerAttrs, "
        "::FlexFlow::NormInitializerAttrs, "
        "::FlexFlow::ConstantInitializerAttrs], received T");
    return std::get<T>(this->raw_variant);
  }
  template <typename T>
  T &get() {
    static_assert(
        IsPartOfInitializerAttrs_v<T>,
        "InitializerAttrs::get() expected one of "
        "[::FlexFlow::GlorotUniformAttrs, ::FlexFlow::ZeroInitializerAttrs, "
        "::FlexFlow::UniformInitializerAttrs, "
        "::FlexFlow::NormInitializerAttrs, "
        "::FlexFlow::ConstantInitializerAttrs], received T");
    return std::get<T>(this->raw_variant);
  }
  size_t index() const {
    return this->raw_variant.index();
  }
  bool operator==(InitializerAttrs const &) const;
  bool operator!=(InitializerAttrs const &) const;
  bool operator<(InitializerAttrs const &) const;
  bool operator>(InitializerAttrs const &) const;
  bool operator<=(InitializerAttrs const &) const;
  bool operator>=(InitializerAttrs const &) const;
  std::variant<::FlexFlow::GlorotUniformAttrs,
               ::FlexFlow::ZeroInitializerAttrs,
               ::FlexFlow::UniformInitializerAttrs,
               ::FlexFlow::NormInitializerAttrs,
               ::FlexFlow::ConstantInitializerAttrs>
      raw_variant;
};
} // namespace FlexFlow
namespace std {
template <>
struct hash<::FlexFlow::InitializerAttrs> {
  size_t operator()(::FlexFlow::InitializerAttrs const &) const;
};
} // namespace std
namespace nlohmann {
template <>
struct adl_serializer<::FlexFlow::InitializerAttrs> {
  static ::FlexFlow::InitializerAttrs from_json(json const &);
  static void to_json(json &, ::FlexFlow::InitializerAttrs const &);
};
} // namespace nlohmann
namespace FlexFlow {
std::string format_as(::FlexFlow::InitializerAttrs const &);
std::ostream &operator<<(std::ostream &, ::FlexFlow::InitializerAttrs const &);
} // namespace FlexFlow

#endif // _FLEXFLOW_LIB_PCG_INCLUDE_PCG_INITIALIZER_ATTRS_DTG_H
