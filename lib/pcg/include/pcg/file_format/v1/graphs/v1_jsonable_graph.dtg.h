// THIS FILE WAS AUTO-GENERATED BY proj. DO NOT MODIFY IT!
// If you would like to modify this datatype, instead modify
// lib/pcg/include/pcg/file_format/v1/graphs/v1_jsonable_graph.struct.toml
/* proj-data
{
  "generated_from": "0595a9f5a6bc19f9a170cb0e42c4202d"
}
*/

#ifndef _FLEXFLOW_LIB_PCG_INCLUDE_PCG_FILE_FORMAT_V1_GRAPHS_V1_JSONABLE_GRAPH_DTG_H
#define _FLEXFLOW_LIB_PCG_INCLUDE_PCG_FILE_FORMAT_V1_GRAPHS_V1_JSONABLE_GRAPH_DTG_H

#include "fmt/format.h"
#include "nlohmann/json.hpp"
#include "pcg/file_format/v1/graphs/v1_graph_output.dtg.h"
#include "pcg/file_format/v1/graphs/v1_multidigraph.dtg.h"
#include <ostream>
#include <sstream>
#include <unordered_map>

namespace FlexFlow {
template <typename NodeT, typename TensorT>
struct V1JsonableGraph {
  V1JsonableGraph() = delete;
  V1JsonableGraph(
      std::unordered_map<size_t, NodeT> const &node_labels,
      std::unordered_map<size_t, ::FlexFlow::V1GraphOutput> const &outputs,
      std::unordered_map<size_t, TensorT> const &output_labels,
      ::FlexFlow::V1MultiDiGraph const &graph);

  std::unordered_map<size_t, NodeT> node_labels;
  std::unordered_map<size_t, ::FlexFlow::V1GraphOutput> outputs;
  std::unordered_map<size_t, TensorT> output_labels;
  ::FlexFlow::V1MultiDiGraph graph;
};
} // namespace FlexFlow

namespace nlohmann {
template <typename NodeT, typename TensorT>
struct adl_serializer<FlexFlow::V1JsonableGraph<NodeT, TensorT>> {
  static FlexFlow::V1JsonableGraph<NodeT, TensorT> from_json(json const &);
  static void to_json(json &,
                      FlexFlow::V1JsonableGraph<NodeT, TensorT> const &);
};
} // namespace nlohmann

namespace FlexFlow {
template <typename NodeT, typename TensorT>
std::string format_as(V1JsonableGraph<NodeT, TensorT> const &);
template <typename NodeT, typename TensorT>
std::ostream &operator<<(std::ostream &,
                         V1JsonableGraph<NodeT, TensorT> const &);
} // namespace FlexFlow

namespace FlexFlow {
template <typename NodeT, typename TensorT>
V1JsonableGraph<NodeT, TensorT>::V1JsonableGraph(
    std::unordered_map<size_t, NodeT> const &node_labels,
    std::unordered_map<size_t, ::FlexFlow::V1GraphOutput> const &outputs,
    std::unordered_map<size_t, TensorT> const &output_labels,
    ::FlexFlow::V1MultiDiGraph const &graph)
    : node_labels(node_labels), outputs(outputs), output_labels(output_labels),
      graph(graph) {}
} // namespace FlexFlow

namespace nlohmann {
template <typename NodeT, typename TensorT>
FlexFlow::V1JsonableGraph<NodeT, TensorT>
    adl_serializer<FlexFlow::V1JsonableGraph<NodeT, TensorT>>::from_json(
        json const &j) {
  return {
      j.at("node_labels").template get<std::unordered_map<size_t, NodeT>>(),
      j.at("outputs")
          .template get<
              std::unordered_map<size_t, ::FlexFlow::V1GraphOutput>>(),
      j.at("output_labels").template get<std::unordered_map<size_t, TensorT>>(),
      j.at("graph").template get<::FlexFlow::V1MultiDiGraph>()};
}
template <typename NodeT, typename TensorT>
void adl_serializer<FlexFlow::V1JsonableGraph<NodeT, TensorT>>::to_json(
    json &j, FlexFlow::V1JsonableGraph<NodeT, TensorT> const &v) {
  j["__type"] = "V1JsonableGraph";
  j["node_labels"] = v.node_labels;
  j["outputs"] = v.outputs;
  j["output_labels"] = v.output_labels;
  j["graph"] = v.graph;
}
} // namespace nlohmann

namespace FlexFlow {
template <typename NodeT, typename TensorT>
std::string format_as(V1JsonableGraph<NodeT, TensorT> const &x) {
  std::ostringstream oss;
  oss << "<V1JsonableGraph";
  oss << " node_labels=" << x.node_labels;
  oss << " outputs=" << x.outputs;
  oss << " output_labels=" << x.output_labels;
  oss << " graph=" << x.graph;
  oss << ">";
  return oss.str();
}
template <typename NodeT, typename TensorT>
std::ostream &operator<<(std::ostream &s,
                         V1JsonableGraph<NodeT, TensorT> const &x) {
  return s << fmt::to_string(x);
}
} // namespace FlexFlow

#endif // _FLEXFLOW_LIB_PCG_INCLUDE_PCG_FILE_FORMAT_V1_GRAPHS_V1_JSONABLE_GRAPH_DTG_H
