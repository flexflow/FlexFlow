// THIS FILE WAS AUTO-GENERATED BY proj. DO NOT MODIFY IT!
// If you would like to modify this datatype, instead modify
// lib/substitutions/include/substitutions/operator_pattern/operator_attribute_value.variant.toml
/* proj-data
{
  "generated_from": "de14592f1f4bcfb52689bc95e9d3b55f"
}
*/

#ifndef _FLEXFLOW_LIB_SUBSTITUTIONS_INCLUDE_SUBSTITUTIONS_OPERATOR_PATTERN_OPERATOR_ATTRIBUTE_VALUE_DTG_H
#define _FLEXFLOW_LIB_SUBSTITUTIONS_INCLUDE_SUBSTITUTIONS_OPERATOR_PATTERN_OPERATOR_ATTRIBUTE_VALUE_DTG_H

#include "fmt/format.h"
#include "nlohmann/json.hpp"
#include "op-attrs/activation.dtg.h"
#include "op-attrs/aggregate_op.dtg.h"
#include "op-attrs/datatype.dtg.h"
#include "op-attrs/ff_dim.dtg.h"
#include "op-attrs/operator_type.dtg.h"
#include "op-attrs/pool_op.dtg.h"
#include "op-attrs/regularizer_attrs.dtg.h"
#include "op-attrs/tensor_shape.dtg.h"
#include <cstddef>
#include <functional>
#include <optional>
#include <ostream>
#include <type_traits>
#include <variant>
#include <vector>

namespace FlexFlow {
struct OperatorAttributeValue {
  OperatorAttributeValue() = delete;
  OperatorAttributeValue(int const &);
  OperatorAttributeValue(bool const &);
  OperatorAttributeValue(std::vector<int> const &);
  OperatorAttributeValue(std::vector<::FlexFlow::ff_dim_t> const &);
  OperatorAttributeValue(::FlexFlow::OperatorType const &);
  OperatorAttributeValue(::FlexFlow::Activation const &);
  OperatorAttributeValue(::FlexFlow::ff_dim_t const &);
  OperatorAttributeValue(size_t const &);
  OperatorAttributeValue(::FlexFlow::AggregateOp const &);
  OperatorAttributeValue(std::optional<::FlexFlow::RegularizerAttrs> const &);
  OperatorAttributeValue(::FlexFlow::PoolOp const &);
  OperatorAttributeValue(::FlexFlow::TensorShape const &);
  OperatorAttributeValue(::FlexFlow::DataType const &);
  template <typename T>
  static constexpr bool IsPartOfOperatorAttributeValue_v =
      std::is_same_v<T, int> || std::is_same_v<T, bool> ||
      std::is_same_v<T, std::vector<int>> ||
      std::is_same_v<T, std::vector<::FlexFlow::ff_dim_t>> ||
      std::is_same_v<T, ::FlexFlow::OperatorType> ||
      std::is_same_v<T, ::FlexFlow::Activation> ||
      std::is_same_v<T, ::FlexFlow::ff_dim_t> || std::is_same_v<T, size_t> ||
      std::is_same_v<T, ::FlexFlow::AggregateOp> ||
      std::is_same_v<T, std::optional<::FlexFlow::RegularizerAttrs>> ||
      std::is_same_v<T, ::FlexFlow::PoolOp> ||
      std::is_same_v<T, ::FlexFlow::TensorShape> ||
      std::is_same_v<T, ::FlexFlow::DataType>;
  template <typename ReturnType, typename Visitor>
  ReturnType visit(Visitor &&v) const {
    switch (this->index()) {
      case 0: {
        ReturnType result = v(this->get<int>());
        return result;
      }
      case 1: {
        ReturnType result = v(this->get<bool>());
        return result;
      }
      case 2: {
        ReturnType result = v(this->get<std::vector<int>>());
        return result;
      }
      case 3: {
        ReturnType result = v(this->get<std::vector<::FlexFlow::ff_dim_t>>());
        return result;
      }
      case 4: {
        ReturnType result = v(this->get<::FlexFlow::OperatorType>());
        return result;
      }
      case 5: {
        ReturnType result = v(this->get<::FlexFlow::Activation>());
        return result;
      }
      case 6: {
        ReturnType result = v(this->get<::FlexFlow::ff_dim_t>());
        return result;
      }
      case 7: {
        ReturnType result = v(this->get<size_t>());
        return result;
      }
      case 8: {
        ReturnType result = v(this->get<::FlexFlow::AggregateOp>());
        return result;
      }
      case 9: {
        ReturnType result =
            v(this->get<std::optional<::FlexFlow::RegularizerAttrs>>());
        return result;
      }
      case 10: {
        ReturnType result = v(this->get<::FlexFlow::PoolOp>());
        return result;
      }
      case 11: {
        ReturnType result = v(this->get<::FlexFlow::TensorShape>());
        return result;
      }
      case 12: {
        ReturnType result = v(this->get<::FlexFlow::DataType>());
        return result;
      }
      default: {
        throw std::runtime_error(fmt::format(
            "Unknown index {} for type OperatorAttributeValue", this->index()));
      }
    }
  }
  template <typename ReturnType, typename Visitor>
  ReturnType visit(Visitor &&v) {
    switch (this->index()) {
      case 0: {
        ReturnType result = v(this->get<int>());
        return result;
      }
      case 1: {
        ReturnType result = v(this->get<bool>());
        return result;
      }
      case 2: {
        ReturnType result = v(this->get<std::vector<int>>());
        return result;
      }
      case 3: {
        ReturnType result = v(this->get<std::vector<::FlexFlow::ff_dim_t>>());
        return result;
      }
      case 4: {
        ReturnType result = v(this->get<::FlexFlow::OperatorType>());
        return result;
      }
      case 5: {
        ReturnType result = v(this->get<::FlexFlow::Activation>());
        return result;
      }
      case 6: {
        ReturnType result = v(this->get<::FlexFlow::ff_dim_t>());
        return result;
      }
      case 7: {
        ReturnType result = v(this->get<size_t>());
        return result;
      }
      case 8: {
        ReturnType result = v(this->get<::FlexFlow::AggregateOp>());
        return result;
      }
      case 9: {
        ReturnType result =
            v(this->get<std::optional<::FlexFlow::RegularizerAttrs>>());
        return result;
      }
      case 10: {
        ReturnType result = v(this->get<::FlexFlow::PoolOp>());
        return result;
      }
      case 11: {
        ReturnType result = v(this->get<::FlexFlow::TensorShape>());
        return result;
      }
      case 12: {
        ReturnType result = v(this->get<::FlexFlow::DataType>());
        return result;
      }
      default: {
        throw std::runtime_error(fmt::format(
            "Unknown index {} for type OperatorAttributeValue", this->index()));
      }
    }
  }
  template <typename T>
  bool has() const {
    static_assert(
        IsPartOfOperatorAttributeValue_v<T>,
        "OperatorAttributeValue::has() expected one of [int, bool, "
        "std::vector<int>, std::vector<::FlexFlow::ff_dim_t>, "
        "::FlexFlow::OperatorType, ::FlexFlow::Activation, "
        "::FlexFlow::ff_dim_t, size_t, ::FlexFlow::AggregateOp, "
        "std::optional<::FlexFlow::RegularizerAttrs>, ::FlexFlow::PoolOp, "
        "::FlexFlow::TensorShape, ::FlexFlow::DataType], received T");
    return std::holds_alternative<T>(this->raw_variant);
  }
  template <typename T>
  T const &get() const {
    static_assert(
        IsPartOfOperatorAttributeValue_v<T>,
        "OperatorAttributeValue::get() expected one of [int, bool, "
        "std::vector<int>, std::vector<::FlexFlow::ff_dim_t>, "
        "::FlexFlow::OperatorType, ::FlexFlow::Activation, "
        "::FlexFlow::ff_dim_t, size_t, ::FlexFlow::AggregateOp, "
        "std::optional<::FlexFlow::RegularizerAttrs>, ::FlexFlow::PoolOp, "
        "::FlexFlow::TensorShape, ::FlexFlow::DataType], received T");
    return std::get<T>(this->raw_variant);
  }
  template <typename T>
  T &get() {
    static_assert(
        IsPartOfOperatorAttributeValue_v<T>,
        "OperatorAttributeValue::get() expected one of [int, bool, "
        "std::vector<int>, std::vector<::FlexFlow::ff_dim_t>, "
        "::FlexFlow::OperatorType, ::FlexFlow::Activation, "
        "::FlexFlow::ff_dim_t, size_t, ::FlexFlow::AggregateOp, "
        "std::optional<::FlexFlow::RegularizerAttrs>, ::FlexFlow::PoolOp, "
        "::FlexFlow::TensorShape, ::FlexFlow::DataType], received T");
    return std::get<T>(this->raw_variant);
  }
  size_t index() const {
    return this->raw_variant.index();
  }
  bool operator==(OperatorAttributeValue const &) const;
  bool operator!=(OperatorAttributeValue const &) const;
  bool operator<(OperatorAttributeValue const &) const;
  bool operator>(OperatorAttributeValue const &) const;
  bool operator<=(OperatorAttributeValue const &) const;
  bool operator>=(OperatorAttributeValue const &) const;
  std::variant<int,
               bool,
               std::vector<int>,
               std::vector<::FlexFlow::ff_dim_t>,
               ::FlexFlow::OperatorType,
               ::FlexFlow::Activation,
               ::FlexFlow::ff_dim_t,
               size_t,
               ::FlexFlow::AggregateOp,
               std::optional<::FlexFlow::RegularizerAttrs>,
               ::FlexFlow::PoolOp,
               ::FlexFlow::TensorShape,
               ::FlexFlow::DataType>
      raw_variant;
};
} // namespace FlexFlow
namespace std {
template <>
struct hash<::FlexFlow::OperatorAttributeValue> {
  size_t operator()(::FlexFlow::OperatorAttributeValue const &) const;
};
} // namespace std
namespace nlohmann {
template <>
struct adl_serializer<::FlexFlow::OperatorAttributeValue> {
  static ::FlexFlow::OperatorAttributeValue from_json(json const &);
  static void to_json(json &, ::FlexFlow::OperatorAttributeValue const &);
};
} // namespace nlohmann
namespace FlexFlow {
std::string format_as(::FlexFlow::OperatorAttributeValue const &);
std::ostream &operator<<(std::ostream &,
                         ::FlexFlow::OperatorAttributeValue const &);
} // namespace FlexFlow

#endif // _FLEXFLOW_LIB_SUBSTITUTIONS_INCLUDE_SUBSTITUTIONS_OPERATOR_PATTERN_OPERATOR_ATTRIBUTE_VALUE_DTG_H
