// THIS FILE WAS AUTO-GENERATED BY proj. DO NOT MODIFY IT!
// If you would like to modify this datatype, instead modify
// lib/substitutions/include/substitutions/operator_pattern/operator_attribute_constraint.struct.toml
/* proj-data
{
  "generated_from": "7867bd0f403866c13417171bb5ec364c"
}
*/

#include "substitutions/operator_pattern/operator_attribute_constraint.dtg.h"

#include "substitutions/constraint_type.dtg.h"
#include "substitutions/operator_pattern/operator_attribute_expr.dtg.h"
#include "substitutions/operator_pattern/operator_attribute_value.dtg.h"
#include <sstream>

namespace FlexFlow {
OperatorAttributeConstraint::OperatorAttributeConstraint(
    ::FlexFlow::ConstraintType const &constraint_type,
    ::FlexFlow::OperatorAttributeExpr const &attribute_expr,
    ::FlexFlow::OperatorAttributeValue const &attribute_value)
    : constraint_type(constraint_type), attribute_expr(attribute_expr),
      attribute_value(attribute_value) {}
bool OperatorAttributeConstraint::operator==(
    OperatorAttributeConstraint const &other) const {
  return std::tie(this->constraint_type,
                  this->attribute_expr,
                  this->attribute_value) == std::tie(other.constraint_type,
                                                     other.attribute_expr,
                                                     other.attribute_value);
}
bool OperatorAttributeConstraint::operator!=(
    OperatorAttributeConstraint const &other) const {
  return std::tie(this->constraint_type,
                  this->attribute_expr,
                  this->attribute_value) != std::tie(other.constraint_type,
                                                     other.attribute_expr,
                                                     other.attribute_value);
}
bool OperatorAttributeConstraint::operator<(
    OperatorAttributeConstraint const &other) const {
  return std::tie(this->constraint_type,
                  this->attribute_expr,
                  this->attribute_value) < std::tie(other.constraint_type,
                                                    other.attribute_expr,
                                                    other.attribute_value);
}
bool OperatorAttributeConstraint::operator>(
    OperatorAttributeConstraint const &other) const {
  return std::tie(this->constraint_type,
                  this->attribute_expr,
                  this->attribute_value) > std::tie(other.constraint_type,
                                                    other.attribute_expr,
                                                    other.attribute_value);
}
bool OperatorAttributeConstraint::operator<=(
    OperatorAttributeConstraint const &other) const {
  return std::tie(this->constraint_type,
                  this->attribute_expr,
                  this->attribute_value) <= std::tie(other.constraint_type,
                                                     other.attribute_expr,
                                                     other.attribute_value);
}
bool OperatorAttributeConstraint::operator>=(
    OperatorAttributeConstraint const &other) const {
  return std::tie(this->constraint_type,
                  this->attribute_expr,
                  this->attribute_value) >= std::tie(other.constraint_type,
                                                     other.attribute_expr,
                                                     other.attribute_value);
}
} // namespace FlexFlow

namespace std {
size_t hash<FlexFlow::OperatorAttributeConstraint>::operator()(
    FlexFlow::OperatorAttributeConstraint const &x) const {
  size_t result = 0;
  result ^= std::hash<::FlexFlow::ConstraintType>{}(x.constraint_type) +
            0x9e3779b9 + (result << 6) + (result >> 2);
  result ^= std::hash<::FlexFlow::OperatorAttributeExpr>{}(x.attribute_expr) +
            0x9e3779b9 + (result << 6) + (result >> 2);
  result ^= std::hash<::FlexFlow::OperatorAttributeValue>{}(x.attribute_value) +
            0x9e3779b9 + (result << 6) + (result >> 2);
  return result;
}
} // namespace std

namespace nlohmann {
FlexFlow::OperatorAttributeConstraint
    adl_serializer<FlexFlow::OperatorAttributeConstraint>::from_json(
        json const &j) {
  return {
      j.at("constraint_type").template get<::FlexFlow::ConstraintType>(),
      j.at("attribute_expr").template get<::FlexFlow::OperatorAttributeExpr>(),
      j.at("attribute_value")
          .template get<::FlexFlow::OperatorAttributeValue>()};
}
void adl_serializer<FlexFlow::OperatorAttributeConstraint>::to_json(
    json &j, FlexFlow::OperatorAttributeConstraint const &v) {
  j["__type"] = "OperatorAttributeConstraint";
  j["constraint_type"] = v.constraint_type;
  j["attribute_expr"] = v.attribute_expr;
  j["attribute_value"] = v.attribute_value;
}
} // namespace nlohmann

namespace FlexFlow {
std::string format_as(OperatorAttributeConstraint const &x) {
  std::ostringstream oss;
  oss << "<OperatorAttributeConstraint";
  oss << " constraint_type=" << x.constraint_type;
  oss << " attribute_expr=" << x.attribute_expr;
  oss << " attribute_value=" << x.attribute_value;
  oss << ">";
  return oss.str();
}
std::ostream &operator<<(std::ostream &s,
                         OperatorAttributeConstraint const &x) {
  return s << fmt::to_string(x);
}
} // namespace FlexFlow
