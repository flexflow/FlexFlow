// THIS FILE WAS AUTO-GENERATED BY proj. DO NOT MODIFY IT!
// If you would like to modify this datatype, instead modify
// lib/substitutions/include/substitutions/tensor_pattern/tensor_attribute_constraint.struct.toml
/* proj-data
{
  "generated_from": "29dbf81668bc864b06af52261060335e"
}
*/

#include "substitutions/tensor_pattern/tensor_attribute_constraint.dtg.h"

#include "substitutions/constraint_type.dtg.h"
#include "substitutions/tensor_pattern/tensor_attribute_expr.dtg.h"
#include "substitutions/tensor_pattern/tensor_attribute_value.dtg.h"
#include <sstream>

namespace FlexFlow {
TensorAttributeConstraint::TensorAttributeConstraint(
    ::FlexFlow::ConstraintType const &constraint_type,
    ::FlexFlow::TensorAttributeExpr const &attribute_expr,
    ::FlexFlow::TensorAttributeValue const &attribute_value)
    : constraint_type(constraint_type), attribute_expr(attribute_expr),
      attribute_value(attribute_value) {}
bool TensorAttributeConstraint::operator==(
    TensorAttributeConstraint const &other) const {
  return std::tie(this->constraint_type,
                  this->attribute_expr,
                  this->attribute_value) == std::tie(other.constraint_type,
                                                     other.attribute_expr,
                                                     other.attribute_value);
}
bool TensorAttributeConstraint::operator!=(
    TensorAttributeConstraint const &other) const {
  return std::tie(this->constraint_type,
                  this->attribute_expr,
                  this->attribute_value) != std::tie(other.constraint_type,
                                                     other.attribute_expr,
                                                     other.attribute_value);
}
bool TensorAttributeConstraint::operator<(
    TensorAttributeConstraint const &other) const {
  return std::tie(this->constraint_type,
                  this->attribute_expr,
                  this->attribute_value) < std::tie(other.constraint_type,
                                                    other.attribute_expr,
                                                    other.attribute_value);
}
bool TensorAttributeConstraint::operator>(
    TensorAttributeConstraint const &other) const {
  return std::tie(this->constraint_type,
                  this->attribute_expr,
                  this->attribute_value) > std::tie(other.constraint_type,
                                                    other.attribute_expr,
                                                    other.attribute_value);
}
bool TensorAttributeConstraint::operator<=(
    TensorAttributeConstraint const &other) const {
  return std::tie(this->constraint_type,
                  this->attribute_expr,
                  this->attribute_value) <= std::tie(other.constraint_type,
                                                     other.attribute_expr,
                                                     other.attribute_value);
}
bool TensorAttributeConstraint::operator>=(
    TensorAttributeConstraint const &other) const {
  return std::tie(this->constraint_type,
                  this->attribute_expr,
                  this->attribute_value) >= std::tie(other.constraint_type,
                                                     other.attribute_expr,
                                                     other.attribute_value);
}
} // namespace FlexFlow

namespace std {
size_t hash<FlexFlow::TensorAttributeConstraint>::operator()(
    ::FlexFlow::TensorAttributeConstraint const &x) const {
  size_t result = 0;
  result ^= std::hash<::FlexFlow::ConstraintType>{}(x.constraint_type) +
            0x9e3779b9 + (result << 6) + (result >> 2);
  result ^= std::hash<::FlexFlow::TensorAttributeExpr>{}(x.attribute_expr) +
            0x9e3779b9 + (result << 6) + (result >> 2);
  result ^= std::hash<::FlexFlow::TensorAttributeValue>{}(x.attribute_value) +
            0x9e3779b9 + (result << 6) + (result >> 2);
  return result;
}
} // namespace std

namespace nlohmann {
::FlexFlow::TensorAttributeConstraint
    adl_serializer<::FlexFlow::TensorAttributeConstraint>::from_json(
        json const &j) {
  return ::FlexFlow::TensorAttributeConstraint{
      j.at("constraint_type").template get<::FlexFlow::ConstraintType>(),
      j.at("attribute_expr").template get<::FlexFlow::TensorAttributeExpr>(),
      j.at("attribute_value").template get<::FlexFlow::TensorAttributeValue>()};
}
void adl_serializer<::FlexFlow::TensorAttributeConstraint>::to_json(
    json &j, ::FlexFlow::TensorAttributeConstraint const &v) {
  j["__type"] = "TensorAttributeConstraint";
  j["constraint_type"] = v.constraint_type;
  j["attribute_expr"] = v.attribute_expr;
  j["attribute_value"] = v.attribute_value;
}
} // namespace nlohmann

namespace FlexFlow {
std::string format_as(TensorAttributeConstraint const &x) {
  std::ostringstream oss;
  oss << "<TensorAttributeConstraint";
  oss << " constraint_type=" << x.constraint_type;
  oss << " attribute_expr=" << x.attribute_expr;
  oss << " attribute_value=" << x.attribute_value;
  oss << ">";
  return oss.str();
}
std::ostream &operator<<(std::ostream &s, TensorAttributeConstraint const &x) {
  return s << fmt::to_string(x);
}
} // namespace FlexFlow
