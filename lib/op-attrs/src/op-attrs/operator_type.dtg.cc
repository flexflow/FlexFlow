// THIS FILE WAS AUTO-GENERATED BY proj. DO NOT MODIFY IT!
// If you would like to modify this datatype, instead modify
// lib/op-attrs/include/op-attrs/operator_type.enum.toml
/* proj-data
{
  "generated_from": "c1c4687ef2fbc7dad996e5c25d47124c"
}
*/

#include "op-attrs/operator_type.dtg.h"

#include <sstream>
#include <stdexcept>

namespace std {
size_t
    hash<FlexFlow::OperatorType>::operator()(FlexFlow::OperatorType x) const {
  return std::hash<int>{}(static_cast<int>(x));
}
} // namespace std
namespace FlexFlow {
std::string format_as(OperatorType x) {
  switch (x) {
    case OperatorType::NOOP:
      return "NOOP";
    case OperatorType::INPUT:
      return "INPUT";
    case OperatorType::WEIGHT:
      return "WEIGHT";
    case OperatorType::CONV2D:
      return "CONV2D";
    case OperatorType::DROPOUT:
      return "DROPOUT";
    case OperatorType::LINEAR:
      return "LINEAR";
    case OperatorType::BATCHMATMUL:
      return "BATCHMATMUL";
    case OperatorType::POOL2D:
      return "POOL2D";
    case OperatorType::SCALAR_MULTIPLY:
      return "SCALAR_MULTIPLY";
    case OperatorType::SCALAR_ADD:
      return "SCALAR_ADD";
    case OperatorType::SCALAR_FLOOR_DIV:
      return "SCALAR_FLOOR_DIV";
    case OperatorType::SCALAR_TRUE_DIV:
      return "SCALAR_TRUE_DIV";
    case OperatorType::SCALAR_SUB:
      return "SCALAR_SUB";
    case OperatorType::RELU:
      return "RELU";
    case OperatorType::IDENTITY:
      return "IDENTITY";
    case OperatorType::SIGMOID:
      return "SIGMOID";
    case OperatorType::TANH:
      return "TANH";
    case OperatorType::ELU:
      return "ELU";
    case OperatorType::FLAT:
      return "FLAT";
    case OperatorType::SOFTMAX:
      return "SOFTMAX";
    case OperatorType::BATCHNORM:
      return "BATCHNORM";
    case OperatorType::CONCAT:
      return "CONCAT";
    case OperatorType::SPLIT:
      return "SPLIT";
    case OperatorType::EMBEDDING:
      return "EMBEDDING";
    case OperatorType::CACHE:
      return "CACHE";
    case OperatorType::RESHAPE:
      return "RESHAPE";
    case OperatorType::REVERSE:
      return "REVERSE";
    case OperatorType::TRANSPOSE:
      return "TRANSPOSE";
    case OperatorType::EW_ADD:
      return "EW_ADD";
    case OperatorType::EW_MUL:
      return "EW_MUL";
    case OperatorType::MATMUL:
      return "MATMUL";
    case OperatorType::MUL:
      return "MUL";
    case OperatorType::ENLARGE:
      return "ENLARGE";
    case OperatorType::SQUEEZE:
      return "SQUEEZE";
    case OperatorType::UNSQUEEZE:
      return "UNSQUEEZE";
    case OperatorType::EW_SUB:
      return "EW_SUB";
    case OperatorType::EW_DIV:
      return "EW_DIV";
    case OperatorType::EW_EQUAL:
      return "EW_EQUAL";
    case OperatorType::EW_GREATER:
      return "EW_GREATER";
    case OperatorType::EW_LESS:
      return "EW_LESS";
    case OperatorType::EW_MAX:
      return "EW_MAX";
    case OperatorType::EW_MIN:
      return "EW_MIN";
    case OperatorType::REDUCE_ARGMAX:
      return "REDUCE_ARGMAX";
    case OperatorType::REDUCE_ARGMIN:
      return "REDUCE_ARGMIN";
    case OperatorType::REDUCE_MAX:
      return "REDUCE_MAX";
    case OperatorType::REDUCE_MEAN:
      return "REDUCE_MEAN";
    case OperatorType::REDUCE_MIN:
      return "REDUCE_MIN";
    case OperatorType::REDUCE_PROD:
      return "REDUCE_PROD";
    case OperatorType::REDUCE_SUM:
      return "REDUCE_SUM";
    case OperatorType::PAD:
      return "PAD";
    case OperatorType::SHAPE:
      return "SHAPE";
    case OperatorType::SIZE:
      return "SIZE";
    case OperatorType::TOPK:
      return "TOPK";
    case OperatorType::WHERE:
      return "WHERE";
    case OperatorType::CEIL:
      return "CEIL";
    case OperatorType::CAST:
      return "CAST";
    case OperatorType::EXP:
      return "EXP";
    case OperatorType::ROUND:
      return "ROUND";
    case OperatorType::LOG:
      return "LOG";
    case OperatorType::LOGICAL_NOT:
      return "LOGICAL_NOT";
    case OperatorType::SQRT:
      return "SQRT";
    case OperatorType::SIN:
      return "SIN";
    case OperatorType::COS:
      return "COS";
    case OperatorType::LEAKYRELU:
      return "LEAKYRELU";
    case OperatorType::SLICE:
      return "SLICE";
    case OperatorType::RESIZE:
      return "RESIZE";
    case OperatorType::PRELU:
      return "PRELU";
    case OperatorType::GELU:
      return "GELU";
    case OperatorType::MULTIHEAD_ATTENTION:
      return "MULTIHEAD_ATTENTION";
    case OperatorType::FUSED:
      return "FUSED";
    case OperatorType::RSQRT:
      return "RSQRT";
    case OperatorType::POW:
      return "POW";
    case OperatorType::MEAN:
      return "MEAN";
    case OperatorType::LAYERNORM:
      return "LAYERNORM";
    case OperatorType::GATHER:
      return "GATHER";
    case OperatorType::BROADCAST:
      return "BROADCAST";
    case OperatorType::REPARTITION:
      return "REPARTITION";
    case OperatorType::COMBINE:
      return "COMBINE";
    case OperatorType::REPLICATE:
      return "REPLICATE";
    case OperatorType::REDUCTION:
      return "REDUCTION";
    case OperatorType::BATCH:
      return "BATCH";
    case OperatorType::PIPELINE:
      return "PIPELINE";
    case OperatorType::FUSED_PARALLEL:
      return "FUSED_PARALLEL";
    default:
      std::ostringstream oss;
      oss << "Unknown OperatorType value " << static_cast<int>(x);
      throw std::runtime_error(oss.str());
  }
}
std::ostream &operator<<(std::ostream &s, OperatorType x) {
  return s << fmt::to_string(x);
}
} // namespace FlexFlow
namespace FlexFlow {
void to_json(::nlohmann::json &j, OperatorType x) {
  switch (x) {
    case OperatorType::NOOP:
      j = "NOOP";
      break;
    case OperatorType::INPUT:
      j = "INPUT";
      break;
    case OperatorType::WEIGHT:
      j = "WEIGHT";
      break;
    case OperatorType::CONV2D:
      j = "CONV2D";
      break;
    case OperatorType::DROPOUT:
      j = "DROPOUT";
      break;
    case OperatorType::LINEAR:
      j = "LINEAR";
      break;
    case OperatorType::BATCHMATMUL:
      j = "BATCHMATMUL";
      break;
    case OperatorType::POOL2D:
      j = "POOL2D";
      break;
    case OperatorType::SCALAR_MULTIPLY:
      j = "SCALAR_MULTIPLY";
      break;
    case OperatorType::SCALAR_ADD:
      j = "SCALAR_ADD";
      break;
    case OperatorType::SCALAR_FLOOR_DIV:
      j = "SCALAR_FLOOR_DIV";
      break;
    case OperatorType::SCALAR_TRUE_DIV:
      j = "SCALAR_TRUE_DIV";
      break;
    case OperatorType::SCALAR_SUB:
      j = "SCALAR_SUB";
      break;
    case OperatorType::RELU:
      j = "RELU";
      break;
    case OperatorType::IDENTITY:
      j = "IDENTITY";
      break;
    case OperatorType::SIGMOID:
      j = "SIGMOID";
      break;
    case OperatorType::TANH:
      j = "TANH";
      break;
    case OperatorType::ELU:
      j = "ELU";
      break;
    case OperatorType::FLAT:
      j = "FLAT";
      break;
    case OperatorType::SOFTMAX:
      j = "SOFTMAX";
      break;
    case OperatorType::BATCHNORM:
      j = "BATCHNORM";
      break;
    case OperatorType::CONCAT:
      j = "CONCAT";
      break;
    case OperatorType::SPLIT:
      j = "SPLIT";
      break;
    case OperatorType::EMBEDDING:
      j = "EMBEDDING";
      break;
    case OperatorType::CACHE:
      j = "CACHE";
      break;
    case OperatorType::RESHAPE:
      j = "RESHAPE";
      break;
    case OperatorType::REVERSE:
      j = "REVERSE";
      break;
    case OperatorType::TRANSPOSE:
      j = "TRANSPOSE";
      break;
    case OperatorType::EW_ADD:
      j = "EW_ADD";
      break;
    case OperatorType::EW_MUL:
      j = "EW_MUL";
      break;
    case OperatorType::MATMUL:
      j = "MATMUL";
      break;
    case OperatorType::MUL:
      j = "MUL";
      break;
    case OperatorType::ENLARGE:
      j = "ENLARGE";
      break;
    case OperatorType::SQUEEZE:
      j = "SQUEEZE";
      break;
    case OperatorType::UNSQUEEZE:
      j = "UNSQUEEZE";
      break;
    case OperatorType::EW_SUB:
      j = "EW_SUB";
      break;
    case OperatorType::EW_DIV:
      j = "EW_DIV";
      break;
    case OperatorType::EW_EQUAL:
      j = "EW_EQUAL";
      break;
    case OperatorType::EW_GREATER:
      j = "EW_GREATER";
      break;
    case OperatorType::EW_LESS:
      j = "EW_LESS";
      break;
    case OperatorType::EW_MAX:
      j = "EW_MAX";
      break;
    case OperatorType::EW_MIN:
      j = "EW_MIN";
      break;
    case OperatorType::REDUCE_ARGMAX:
      j = "REDUCE_ARGMAX";
      break;
    case OperatorType::REDUCE_ARGMIN:
      j = "REDUCE_ARGMIN";
      break;
    case OperatorType::REDUCE_MAX:
      j = "REDUCE_MAX";
      break;
    case OperatorType::REDUCE_MEAN:
      j = "REDUCE_MEAN";
      break;
    case OperatorType::REDUCE_MIN:
      j = "REDUCE_MIN";
      break;
    case OperatorType::REDUCE_PROD:
      j = "REDUCE_PROD";
      break;
    case OperatorType::REDUCE_SUM:
      j = "REDUCE_SUM";
      break;
    case OperatorType::PAD:
      j = "PAD";
      break;
    case OperatorType::SHAPE:
      j = "SHAPE";
      break;
    case OperatorType::SIZE:
      j = "SIZE";
      break;
    case OperatorType::TOPK:
      j = "TOPK";
      break;
    case OperatorType::WHERE:
      j = "WHERE";
      break;
    case OperatorType::CEIL:
      j = "CEIL";
      break;
    case OperatorType::CAST:
      j = "CAST";
      break;
    case OperatorType::EXP:
      j = "EXP";
      break;
    case OperatorType::ROUND:
      j = "ROUND";
      break;
    case OperatorType::LOG:
      j = "LOG";
      break;
    case OperatorType::LOGICAL_NOT:
      j = "LOGICAL_NOT";
      break;
    case OperatorType::SQRT:
      j = "SQRT";
      break;
    case OperatorType::SIN:
      j = "SIN";
      break;
    case OperatorType::COS:
      j = "COS";
      break;
    case OperatorType::LEAKYRELU:
      j = "LEAKYRELU";
      break;
    case OperatorType::SLICE:
      j = "SLICE";
      break;
    case OperatorType::RESIZE:
      j = "RESIZE";
      break;
    case OperatorType::PRELU:
      j = "PRELU";
      break;
    case OperatorType::GELU:
      j = "GELU";
      break;
    case OperatorType::MULTIHEAD_ATTENTION:
      j = "MULTIHEAD_ATTENTION";
      break;
    case OperatorType::FUSED:
      j = "FUSED";
      break;
    case OperatorType::RSQRT:
      j = "RSQRT";
      break;
    case OperatorType::POW:
      j = "POW";
      break;
    case OperatorType::MEAN:
      j = "MEAN";
      break;
    case OperatorType::LAYERNORM:
      j = "LAYERNORM";
      break;
    case OperatorType::GATHER:
      j = "GATHER";
      break;
    case OperatorType::BROADCAST:
      j = "BROADCAST";
      break;
    case OperatorType::REPARTITION:
      j = "REPARTITION";
      break;
    case OperatorType::COMBINE:
      j = "COMBINE";
      break;
    case OperatorType::REPLICATE:
      j = "REPLICATE";
      break;
    case OperatorType::REDUCTION:
      j = "REDUCTION";
      break;
    case OperatorType::BATCH:
      j = "BATCH";
      break;
    case OperatorType::PIPELINE:
      j = "PIPELINE";
      break;
    case OperatorType::FUSED_PARALLEL:
      j = "FUSED_PARALLEL";
      break;
    default:
      std::ostringstream oss;
      oss << "Unknown OperatorType value " << static_cast<int>(x);
      throw std::runtime_error(oss.str());
  }
}
void from_json(::nlohmann::json const &j, OperatorType &x) {
  std::string as_str = j.get<std::string>();
  if (as_str == "NOOP") {
    x = OperatorType::NOOP;
  } else if (as_str == "INPUT") {
    x = OperatorType::INPUT;
  } else if (as_str == "WEIGHT") {
    x = OperatorType::WEIGHT;
  } else if (as_str == "CONV2D") {
    x = OperatorType::CONV2D;
  } else if (as_str == "DROPOUT") {
    x = OperatorType::DROPOUT;
  } else if (as_str == "LINEAR") {
    x = OperatorType::LINEAR;
  } else if (as_str == "BATCHMATMUL") {
    x = OperatorType::BATCHMATMUL;
  } else if (as_str == "POOL2D") {
    x = OperatorType::POOL2D;
  } else if (as_str == "SCALAR_MULTIPLY") {
    x = OperatorType::SCALAR_MULTIPLY;
  } else if (as_str == "SCALAR_ADD") {
    x = OperatorType::SCALAR_ADD;
  } else if (as_str == "SCALAR_FLOOR_DIV") {
    x = OperatorType::SCALAR_FLOOR_DIV;
  } else if (as_str == "SCALAR_TRUE_DIV") {
    x = OperatorType::SCALAR_TRUE_DIV;
  } else if (as_str == "SCALAR_SUB") {
    x = OperatorType::SCALAR_SUB;
  } else if (as_str == "RELU") {
    x = OperatorType::RELU;
  } else if (as_str == "IDENTITY") {
    x = OperatorType::IDENTITY;
  } else if (as_str == "SIGMOID") {
    x = OperatorType::SIGMOID;
  } else if (as_str == "TANH") {
    x = OperatorType::TANH;
  } else if (as_str == "ELU") {
    x = OperatorType::ELU;
  } else if (as_str == "FLAT") {
    x = OperatorType::FLAT;
  } else if (as_str == "SOFTMAX") {
    x = OperatorType::SOFTMAX;
  } else if (as_str == "BATCHNORM") {
    x = OperatorType::BATCHNORM;
  } else if (as_str == "CONCAT") {
    x = OperatorType::CONCAT;
  } else if (as_str == "SPLIT") {
    x = OperatorType::SPLIT;
  } else if (as_str == "EMBEDDING") {
    x = OperatorType::EMBEDDING;
  } else if (as_str == "CACHE") {
    x = OperatorType::CACHE;
  } else if (as_str == "RESHAPE") {
    x = OperatorType::RESHAPE;
  } else if (as_str == "REVERSE") {
    x = OperatorType::REVERSE;
  } else if (as_str == "TRANSPOSE") {
    x = OperatorType::TRANSPOSE;
  } else if (as_str == "EW_ADD") {
    x = OperatorType::EW_ADD;
  } else if (as_str == "EW_MUL") {
    x = OperatorType::EW_MUL;
  } else if (as_str == "MATMUL") {
    x = OperatorType::MATMUL;
  } else if (as_str == "MUL") {
    x = OperatorType::MUL;
  } else if (as_str == "ENLARGE") {
    x = OperatorType::ENLARGE;
  } else if (as_str == "SQUEEZE") {
    x = OperatorType::SQUEEZE;
  } else if (as_str == "UNSQUEEZE") {
    x = OperatorType::UNSQUEEZE;
  } else if (as_str == "EW_SUB") {
    x = OperatorType::EW_SUB;
  } else if (as_str == "EW_DIV") {
    x = OperatorType::EW_DIV;
  } else if (as_str == "EW_EQUAL") {
    x = OperatorType::EW_EQUAL;
  } else if (as_str == "EW_GREATER") {
    x = OperatorType::EW_GREATER;
  } else if (as_str == "EW_LESS") {
    x = OperatorType::EW_LESS;
  } else if (as_str == "EW_MAX") {
    x = OperatorType::EW_MAX;
  } else if (as_str == "EW_MIN") {
    x = OperatorType::EW_MIN;
  } else if (as_str == "REDUCE_ARGMAX") {
    x = OperatorType::REDUCE_ARGMAX;
  } else if (as_str == "REDUCE_ARGMIN") {
    x = OperatorType::REDUCE_ARGMIN;
  } else if (as_str == "REDUCE_MAX") {
    x = OperatorType::REDUCE_MAX;
  } else if (as_str == "REDUCE_MEAN") {
    x = OperatorType::REDUCE_MEAN;
  } else if (as_str == "REDUCE_MIN") {
    x = OperatorType::REDUCE_MIN;
  } else if (as_str == "REDUCE_PROD") {
    x = OperatorType::REDUCE_PROD;
  } else if (as_str == "REDUCE_SUM") {
    x = OperatorType::REDUCE_SUM;
  } else if (as_str == "PAD") {
    x = OperatorType::PAD;
  } else if (as_str == "SHAPE") {
    x = OperatorType::SHAPE;
  } else if (as_str == "SIZE") {
    x = OperatorType::SIZE;
  } else if (as_str == "TOPK") {
    x = OperatorType::TOPK;
  } else if (as_str == "WHERE") {
    x = OperatorType::WHERE;
  } else if (as_str == "CEIL") {
    x = OperatorType::CEIL;
  } else if (as_str == "CAST") {
    x = OperatorType::CAST;
  } else if (as_str == "EXP") {
    x = OperatorType::EXP;
  } else if (as_str == "ROUND") {
    x = OperatorType::ROUND;
  } else if (as_str == "LOG") {
    x = OperatorType::LOG;
  } else if (as_str == "LOGICAL_NOT") {
    x = OperatorType::LOGICAL_NOT;
  } else if (as_str == "SQRT") {
    x = OperatorType::SQRT;
  } else if (as_str == "SIN") {
    x = OperatorType::SIN;
  } else if (as_str == "COS") {
    x = OperatorType::COS;
  } else if (as_str == "LEAKYRELU") {
    x = OperatorType::LEAKYRELU;
  } else if (as_str == "SLICE") {
    x = OperatorType::SLICE;
  } else if (as_str == "RESIZE") {
    x = OperatorType::RESIZE;
  } else if (as_str == "PRELU") {
    x = OperatorType::PRELU;
  } else if (as_str == "GELU") {
    x = OperatorType::GELU;
  } else if (as_str == "MULTIHEAD_ATTENTION") {
    x = OperatorType::MULTIHEAD_ATTENTION;
  } else if (as_str == "FUSED") {
    x = OperatorType::FUSED;
  } else if (as_str == "RSQRT") {
    x = OperatorType::RSQRT;
  } else if (as_str == "POW") {
    x = OperatorType::POW;
  } else if (as_str == "MEAN") {
    x = OperatorType::MEAN;
  } else if (as_str == "LAYERNORM") {
    x = OperatorType::LAYERNORM;
  } else if (as_str == "GATHER") {
    x = OperatorType::GATHER;
  } else if (as_str == "BROADCAST") {
    x = OperatorType::BROADCAST;
  } else if (as_str == "REPARTITION") {
    x = OperatorType::REPARTITION;
  } else if (as_str == "COMBINE") {
    x = OperatorType::COMBINE;
  } else if (as_str == "REPLICATE") {
    x = OperatorType::REPLICATE;
  } else if (as_str == "REDUCTION") {
    x = OperatorType::REDUCTION;
  } else if (as_str == "BATCH") {
    x = OperatorType::BATCH;
  } else if (as_str == "PIPELINE") {
    x = OperatorType::PIPELINE;
  } else if (as_str == "FUSED_PARALLEL") {
    x = OperatorType::FUSED_PARALLEL;
  } else {
    std::ostringstream oss;
    oss << "Unknown OperatorType value " << as_str;
    throw std::runtime_error(oss.str());
  }
}
} // namespace FlexFlow
namespace rc {
Gen<FlexFlow::OperatorType> Arbitrary<FlexFlow::OperatorType>::arbitrary() {
  return gen::element<FlexFlow::OperatorType>(
      FlexFlow::OperatorType::NOOP,
      FlexFlow::OperatorType::INPUT,
      FlexFlow::OperatorType::WEIGHT,
      FlexFlow::OperatorType::CONV2D,
      FlexFlow::OperatorType::DROPOUT,
      FlexFlow::OperatorType::LINEAR,
      FlexFlow::OperatorType::BATCHMATMUL,
      FlexFlow::OperatorType::POOL2D,
      FlexFlow::OperatorType::SCALAR_MULTIPLY,
      FlexFlow::OperatorType::SCALAR_ADD,
      FlexFlow::OperatorType::SCALAR_FLOOR_DIV,
      FlexFlow::OperatorType::SCALAR_TRUE_DIV,
      FlexFlow::OperatorType::SCALAR_SUB,
      FlexFlow::OperatorType::RELU,
      FlexFlow::OperatorType::IDENTITY,
      FlexFlow::OperatorType::SIGMOID,
      FlexFlow::OperatorType::TANH,
      FlexFlow::OperatorType::ELU,
      FlexFlow::OperatorType::FLAT,
      FlexFlow::OperatorType::SOFTMAX,
      FlexFlow::OperatorType::BATCHNORM,
      FlexFlow::OperatorType::CONCAT,
      FlexFlow::OperatorType::SPLIT,
      FlexFlow::OperatorType::EMBEDDING,
      FlexFlow::OperatorType::CACHE,
      FlexFlow::OperatorType::RESHAPE,
      FlexFlow::OperatorType::REVERSE,
      FlexFlow::OperatorType::TRANSPOSE,
      FlexFlow::OperatorType::EW_ADD,
      FlexFlow::OperatorType::EW_MUL,
      FlexFlow::OperatorType::MATMUL,
      FlexFlow::OperatorType::MUL,
      FlexFlow::OperatorType::ENLARGE,
      FlexFlow::OperatorType::SQUEEZE,
      FlexFlow::OperatorType::UNSQUEEZE,
      FlexFlow::OperatorType::EW_SUB,
      FlexFlow::OperatorType::EW_DIV,
      FlexFlow::OperatorType::EW_EQUAL,
      FlexFlow::OperatorType::EW_GREATER,
      FlexFlow::OperatorType::EW_LESS,
      FlexFlow::OperatorType::EW_MAX,
      FlexFlow::OperatorType::EW_MIN,
      FlexFlow::OperatorType::REDUCE_ARGMAX,
      FlexFlow::OperatorType::REDUCE_ARGMIN,
      FlexFlow::OperatorType::REDUCE_MAX,
      FlexFlow::OperatorType::REDUCE_MEAN,
      FlexFlow::OperatorType::REDUCE_MIN,
      FlexFlow::OperatorType::REDUCE_PROD,
      FlexFlow::OperatorType::REDUCE_SUM,
      FlexFlow::OperatorType::PAD,
      FlexFlow::OperatorType::SHAPE,
      FlexFlow::OperatorType::SIZE,
      FlexFlow::OperatorType::TOPK,
      FlexFlow::OperatorType::WHERE,
      FlexFlow::OperatorType::CEIL,
      FlexFlow::OperatorType::CAST,
      FlexFlow::OperatorType::EXP,
      FlexFlow::OperatorType::ROUND,
      FlexFlow::OperatorType::LOG,
      FlexFlow::OperatorType::LOGICAL_NOT,
      FlexFlow::OperatorType::SQRT,
      FlexFlow::OperatorType::SIN,
      FlexFlow::OperatorType::COS,
      FlexFlow::OperatorType::LEAKYRELU,
      FlexFlow::OperatorType::SLICE,
      FlexFlow::OperatorType::RESIZE,
      FlexFlow::OperatorType::PRELU,
      FlexFlow::OperatorType::GELU,
      FlexFlow::OperatorType::MULTIHEAD_ATTENTION,
      FlexFlow::OperatorType::FUSED,
      FlexFlow::OperatorType::RSQRT,
      FlexFlow::OperatorType::POW,
      FlexFlow::OperatorType::MEAN,
      FlexFlow::OperatorType::LAYERNORM,
      FlexFlow::OperatorType::GATHER,
      FlexFlow::OperatorType::BROADCAST,
      FlexFlow::OperatorType::REPARTITION,
      FlexFlow::OperatorType::COMBINE,
      FlexFlow::OperatorType::REPLICATE,
      FlexFlow::OperatorType::REDUCTION,
      FlexFlow::OperatorType::BATCH,
      FlexFlow::OperatorType::PIPELINE,
      FlexFlow::OperatorType::FUSED_PARALLEL);
}
} // namespace rc
